/* MprisGui.c generated by valac 0.30.0, the Vala compiler
 * generated from MprisGui.vala, do not modify */

/*
 * MprisGui.vala
 * 
 * Copyright 2014 Ikey Doherty <ikey.doherty@gmail.com>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <gio/gio.h>
#include <gio/gdesktopappinfo.h>
#include <pango/pango.h>


#define TYPE_CLIENT_IMAGE (client_image_get_type ())
#define CLIENT_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLIENT_IMAGE, ClientImage))
#define CLIENT_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLIENT_IMAGE, ClientImageClass))
#define IS_CLIENT_IMAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLIENT_IMAGE))
#define IS_CLIENT_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLIENT_IMAGE))
#define CLIENT_IMAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLIENT_IMAGE, ClientImageClass))

typedef struct _ClientImage ClientImage;
typedef struct _ClientImageClass ClientImageClass;
typedef struct _ClientImagePrivate ClientImagePrivate;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define TYPE_CLIENT_WIDGET (client_widget_get_type ())
#define CLIENT_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLIENT_WIDGET, ClientWidget))
#define CLIENT_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLIENT_WIDGET, ClientWidgetClass))
#define IS_CLIENT_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLIENT_WIDGET))
#define IS_CLIENT_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLIENT_WIDGET))
#define CLIENT_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLIENT_WIDGET, ClientWidgetClass))

typedef struct _ClientWidget ClientWidget;
typedef struct _ClientWidgetClass ClientWidgetClass;
typedef struct _ClientWidgetPrivate ClientWidgetPrivate;

#define TYPE_MPRIS_CLIENT (mpris_client_get_type ())
#define MPRIS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CLIENT, MprisClient))
#define MPRIS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CLIENT, MprisClientClass))
#define IS_MPRIS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CLIENT))
#define IS_MPRIS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CLIENT))
#define MPRIS_CLIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CLIENT, MprisClientClass))

typedef struct _MprisClient MprisClient;
typedef struct _MprisClientClass MprisClientClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block3Data Block3Data;

#define TYPE_MPRIS_IFACE (mpris_iface_get_type ())
#define MPRIS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_IFACE, MprisIface))
#define IS_MPRIS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_IFACE))
#define MPRIS_IFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_IFACE, MprisIfaceIface))

typedef struct _MprisIface MprisIface;
typedef struct _MprisIfaceIface MprisIfaceIface;

#define TYPE_MPRIS_IFACE_PROXY (mpris_iface_proxy_get_type ())

#define TYPE_PLAYER_IFACE (player_iface_get_type ())
#define PLAYER_IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_IFACE, PlayerIface))
#define IS_PLAYER_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_IFACE))
#define PLAYER_IFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_PLAYER_IFACE, PlayerIfaceIface))

typedef struct _PlayerIface PlayerIface;
typedef struct _PlayerIfaceIface PlayerIfaceIface;

#define TYPE_PLAYER_IFACE_PROXY (player_iface_proxy_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_DBUS_PROP_IFACE (dbus_prop_iface_get_type ())
#define DBUS_PROP_IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DBUS_PROP_IFACE, DbusPropIface))
#define IS_DBUS_PROP_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DBUS_PROP_IFACE))
#define DBUS_PROP_IFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_DBUS_PROP_IFACE, DbusPropIfaceIface))

typedef struct _DbusPropIface DbusPropIface;
typedef struct _DbusPropIfaceIface DbusPropIfaceIface;

#define TYPE_DBUS_PROP_IFACE_PROXY (dbus_prop_iface_proxy_get_type ())
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

struct _ClientImage {
	GtkImage parent_instance;
	ClientImagePrivate * priv;
};

struct _ClientImageClass {
	GtkImageClass parent_class;
};

struct _ClientWidget {
	GtkBox parent_instance;
	ClientWidgetPrivate * priv;
};

struct _ClientWidgetClass {
	GtkBoxClass parent_class;
};

struct _ClientWidgetPrivate {
	GtkRevealer* player_revealer;
	GtkImage* background;
	MprisClient* client;
	GtkLabel* title_label;
	GtkLabel* artist_label;
	GtkLabel* album_label;
	GtkButton* prev_btn;
	GtkButton* play_btn;
	GtkButton* next_btn;
	GtkButton* collapse_btn;
	gboolean collapsed;
};

struct _Block3Data {
	int _ref_count_;
	ClientWidget* self;
	MprisClient* client;
};

struct _MprisIfaceIface {
	GTypeInterface parent_iface;
	void (*raise) (MprisIface* self, GError** error);
	void (*quit) (MprisIface* self, GError** error);
	gboolean (*get_can_quit) (MprisIface* self);
	void (*set_can_quit) (MprisIface* self, gboolean value);
	gboolean (*get_fullscreen) (MprisIface* self);
	gboolean (*get_can_set_fullscreen) (MprisIface* self);
	gboolean (*get_can_raise) (MprisIface* self);
	gboolean (*get_has_track_list) (MprisIface* self);
	gchar* (*get_identity) (MprisIface* self);
	gchar* (*get_desktop_entry) (MprisIface* self);
	gchar** (*get_supported_uri_schemes) (MprisIface* self, int* result_length1);
	gchar** (*get_supported_mime_types) (MprisIface* self, int* result_length1);
};

struct _PlayerIfaceIface {
	GTypeInterface parent_iface;
	void (*next) (PlayerIface* self, GError** error);
	void (*previous) (PlayerIface* self, GError** error);
	void (*pause) (PlayerIface* self, GError** error);
	void (*play_pause) (PlayerIface* self, GError** error);
	void (*stop) (PlayerIface* self, GError** error);
	void (*play) (PlayerIface* self, GError** error);
	void (*seek) (PlayerIface* self, gint64 offset, GError** error);
	void (*open_uri) (PlayerIface* self, const gchar* uri, GError** error);
	gchar* (*get_playback_status) (PlayerIface* self);
	gchar* (*get_loop_status) (PlayerIface* self);
	void (*set_loop_status) (PlayerIface* self, const gchar* value);
	gdouble (*get_rate) (PlayerIface* self);
	void (*set_rate) (PlayerIface* self, gdouble value);
	gboolean (*get_shuffle) (PlayerIface* self);
	void (*set_shuffle) (PlayerIface* self, gboolean value);
	GHashTable* (*get_metadata) (PlayerIface* self);
	gdouble (*get_volume) (PlayerIface* self);
	void (*set_volume) (PlayerIface* self, gdouble value);
	gint64 (*get_position) (PlayerIface* self);
	gdouble (*get_minimum_rate) (PlayerIface* self);
	gdouble (*get_maximum_rate) (PlayerIface* self);
	gboolean (*get_can_go_next) (PlayerIface* self);
	gboolean (*get_can_go_previous) (PlayerIface* self);
	gboolean (*get_can_play) (PlayerIface* self);
	gboolean (*get_can_pause) (PlayerIface* self);
	gboolean (*get_can_seek) (PlayerIface* self);
	gboolean (*get_can_control) (PlayerIface* self);
};

struct _DbusPropIfaceIface {
	GTypeInterface parent_iface;
};


static gpointer client_image_parent_class = NULL;
static gpointer client_widget_parent_class = NULL;

#define BACKGROUND_SIZE 160
GType client_image_get_type (void) G_GNUC_CONST;
enum  {
	CLIENT_IMAGE_DUMMY_PROPERTY
};
ClientImage* client_image_new_from_pixbuf (GdkPixbuf* pbuf);
ClientImage* client_image_construct_from_pixbuf (GType object_type, GdkPixbuf* pbuf);
ClientImage* client_image_new_from_icon_name (const gchar* icon_name, GtkIconSize size);
ClientImage* client_image_construct_from_icon_name (GType object_type, const gchar* icon_name, GtkIconSize size);
static gboolean client_image_real_draw (GtkWidget* base, cairo_t* cr);
ClientImage* client_image_new (void);
ClientImage* client_image_construct (GType object_type);
GType client_widget_get_type (void) G_GNUC_CONST;
GType mpris_client_get_type (void) G_GNUC_CONST;
#define CLIENT_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CLIENT_WIDGET, ClientWidgetPrivate))
enum  {
	CLIENT_WIDGET_DUMMY_PROPERTY
};
ClientWidget* client_widget_new (MprisClient* client);
ClientWidget* client_widget_construct (GType object_type, MprisClient* client);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
GType mpris_iface_proxy_get_type (void) G_GNUC_CONST;
guint mpris_iface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType mpris_iface_get_type (void) G_GNUC_CONST;
GType player_iface_proxy_get_type (void) G_GNUC_CONST;
guint player_iface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType player_iface_get_type (void) G_GNUC_CONST;
PlayerIface* mpris_client_get_player (MprisClient* self);
gchar* mpris_iface_get_desktop_entry (MprisIface* self);
GtkWidget* create_row (const gchar* name, const gchar* icon, GIcon* gicon);
gchar* mpris_iface_get_identity (MprisIface* self);
gboolean mpris_iface_get_can_quit (MprisIface* self);
static void ___lambda8_ (Block3Data* _data3_);
static gboolean __lambda9_ (Block3Data* _data3_);
void mpris_iface_quit (MprisIface* self, GError** error);
static gboolean ___lambda9__gsource_func (gpointer self);
static void ____lambda8__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void client_widget_collapse (ClientWidget* self, gboolean collapse);
static void __lambda10_ (ClientWidget* self);
static void ___lambda10__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda11_ (Block3Data* _data3_);
static gboolean __lambda12_ (Block3Data* _data3_);
gboolean player_iface_get_can_go_previous (PlayerIface* self);
void player_iface_previous (PlayerIface* self, GError** error);
static gboolean ___lambda12__gsource_func (gpointer self);
static void ___lambda11__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda13_ (Block3Data* _data3_);
static gboolean __lambda14_ (Block3Data* _data3_);
void player_iface_play_pause (PlayerIface* self, GError** error);
static gboolean ___lambda14__gsource_func (gpointer self);
static void ___lambda13__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda15_ (Block3Data* _data3_);
static gboolean __lambda16_ (Block3Data* _data3_);
gboolean player_iface_get_can_go_next (PlayerIface* self);
void player_iface_next (PlayerIface* self, GError** error);
static gboolean ___lambda16__gsource_func (gpointer self);
static void ___lambda15__gtk_button_clicked (GtkButton* _sender, gpointer self);
void client_widget_update_from_meta (ClientWidget* self);
static void client_widget_update_play_status (ClientWidget* self);
static void client_widget_update_controls (ClientWidget* self);
GType dbus_prop_iface_get_type (void) G_GNUC_CONST;
GType dbus_prop_iface_proxy_get_type (void) G_GNUC_CONST;
guint dbus_prop_iface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
DbusPropIface* mpris_client_get_prop (MprisClient* self);
static void __lambda17_ (ClientWidget* self, const gchar* i, GHashTable* p, gchar** inv, int inv_length1);
static void ___lambda18_ (ClientWidget* self, const gchar* k, GVariant* v);
static gboolean ___lambda19_ (ClientWidget* self);
static gboolean ____lambda19__gsource_func (gpointer self);
static gboolean ____lambda20_ (ClientWidget* self);
static gboolean _____lambda20__gsource_func (gpointer self);
static gboolean _____lambda21_ (ClientWidget* self);
static gboolean ______lambda21__gsource_func (gpointer self);
static void ____lambda18__gh_func (gconstpointer key, gconstpointer value, gpointer self);
static void ___lambda17__dbus_prop_iface_properties_changed (DbusPropIface* _sender, const gchar* iface, GHashTable* changed, gchar** invalid, int invalid_length1, gpointer self);
gchar* player_iface_get_playback_status (PlayerIface* self);
static void client_widget_update_art (ClientWidget* self, const gchar* uri);
GHashTable* player_iface_get_metadata (PlayerIface* self);
static void client_widget_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


ClientImage* client_image_construct_from_pixbuf (GType object_type, GdkPixbuf* pbuf) {
	ClientImage * self = NULL;
	GdkPixbuf* _tmp0_ = NULL;
	g_return_val_if_fail (pbuf != NULL, NULL);
	_tmp0_ = pbuf;
	self = (ClientImage*) g_object_new (object_type, "pixbuf", _tmp0_, NULL);
	return self;
}


ClientImage* client_image_new_from_pixbuf (GdkPixbuf* pbuf) {
	return client_image_construct_from_pixbuf (TYPE_CLIENT_IMAGE, pbuf);
}


ClientImage* client_image_construct_from_icon_name (GType object_type, const gchar* icon_name, GtkIconSize size) {
	ClientImage * self = NULL;
	const gchar* _tmp0_ = NULL;
	GtkIconSize _tmp1_ = 0;
	g_return_val_if_fail (icon_name != NULL, NULL);
	_tmp0_ = icon_name;
	_tmp1_ = size;
	self = (ClientImage*) g_object_new (object_type, "icon-name", _tmp0_, "icon-size", _tmp1_, NULL);
	return self;
}


ClientImage* client_image_new_from_icon_name (const gchar* icon_name, GtkIconSize size) {
	return client_image_construct_from_icon_name (TYPE_CLIENT_IMAGE, icon_name, size);
}


static gboolean client_image_real_draw (GtkWidget* base, cairo_t* cr) {
	ClientImage * self;
	gboolean result = FALSE;
	GtkAllocation alloc = {0};
	GtkAllocation _tmp0_ = {0};
	cairo_surface_t* surf = NULL;
	GtkAllocation _tmp1_ = {0};
	gint _tmp2_ = 0;
	GtkAllocation _tmp3_ = {0};
	gint _tmp4_ = 0;
	cairo_surface_t* _tmp5_ = NULL;
	cairo_t* cr2 = NULL;
	cairo_surface_t* _tmp6_ = NULL;
	cairo_t* _tmp7_ = NULL;
	cairo_t* _tmp8_ = NULL;
	gdouble alpha = 0.0;
	gint start = 0;
	GtkAllocation _tmp9_ = {0};
	gint _tmp10_ = 0;
	gdouble step = 0.0;
	GtkAllocation _tmp11_ = {0};
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	cairo_t* _tmp14_ = NULL;
	GtkAllocation _tmp15_ = {0};
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	cairo_t* _tmp18_ = NULL;
	cairo_t* _tmp19_ = NULL;
	cairo_t* _tmp20_ = NULL;
	cairo_surface_t* _tmp21_ = NULL;
	cairo_t* _tmp22_ = NULL;
	cairo_t* _tmp23_ = NULL;
	self = (ClientImage*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp0_);
	alloc = _tmp0_;
	_tmp1_ = alloc;
	_tmp2_ = _tmp1_.width;
	_tmp3_ = alloc;
	_tmp4_ = _tmp3_.height;
	_tmp5_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp2_, _tmp4_);
	surf = _tmp5_;
	_tmp6_ = surf;
	_tmp7_ = cairo_create (_tmp6_);
	cr2 = _tmp7_;
	_tmp8_ = cr2;
	GTK_WIDGET_CLASS (client_image_parent_class)->draw ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_image_get_type (), GtkImage), _tmp8_);
	alpha = 1.0;
	_tmp9_ = alloc;
	_tmp10_ = _tmp9_.height;
	start = (gint) (_tmp10_ * 0.40);
	_tmp11_ = alloc;
	_tmp12_ = _tmp11_.height;
	_tmp13_ = start;
	step = (1.0 / (_tmp12_ - _tmp13_)) * 1.35;
	_tmp14_ = cr;
	_tmp15_ = alloc;
	_tmp16_ = _tmp15_.width;
	_tmp17_ = start;
	cairo_rectangle (_tmp14_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp16_, (gdouble) _tmp17_);
	_tmp18_ = cr;
	cairo_save (_tmp18_);
	_tmp19_ = cr;
	cairo_clip (_tmp19_);
	_tmp20_ = cr;
	_tmp21_ = surf;
	cairo_set_source_surface (_tmp20_, _tmp21_, (gdouble) 0, (gdouble) 0);
	_tmp22_ = cr;
	cairo_paint (_tmp22_);
	_tmp23_ = cr;
	cairo_restore (_tmp23_);
	{
		gint i = 0;
		gint _tmp24_ = 0;
		_tmp24_ = start;
		i = _tmp24_;
		{
			gboolean _tmp25_ = FALSE;
			_tmp25_ = TRUE;
			while (TRUE) {
				gint _tmp27_ = 0;
				GtkAllocation _tmp28_ = {0};
				gint _tmp29_ = 0;
				cairo_t* _tmp30_ = NULL;
				gint _tmp31_ = 0;
				GtkAllocation _tmp32_ = {0};
				gint _tmp33_ = 0;
				cairo_t* _tmp34_ = NULL;
				cairo_t* _tmp35_ = NULL;
				cairo_t* _tmp36_ = NULL;
				cairo_surface_t* _tmp37_ = NULL;
				cairo_t* _tmp38_ = NULL;
				gdouble _tmp39_ = 0.0;
				cairo_t* _tmp40_ = NULL;
				gdouble _tmp41_ = 0.0;
				gdouble _tmp42_ = 0.0;
				if (!_tmp25_) {
					gint _tmp26_ = 0;
					_tmp26_ = i;
					i = _tmp26_ + 1;
				}
				_tmp25_ = FALSE;
				_tmp27_ = i;
				_tmp28_ = alloc;
				_tmp29_ = _tmp28_.height;
				if (!(_tmp27_ < _tmp29_)) {
					break;
				}
				_tmp30_ = cr;
				_tmp31_ = i;
				_tmp32_ = alloc;
				_tmp33_ = _tmp32_.width;
				cairo_rectangle (_tmp30_, (gdouble) 0, (gdouble) _tmp31_, (gdouble) _tmp33_, (gdouble) 1);
				_tmp34_ = cr;
				cairo_save (_tmp34_);
				_tmp35_ = cr;
				cairo_clip (_tmp35_);
				_tmp36_ = cr;
				_tmp37_ = surf;
				cairo_set_source_surface (_tmp36_, _tmp37_, (gdouble) 0, (gdouble) 0);
				_tmp38_ = cr;
				_tmp39_ = alpha;
				cairo_paint_with_alpha (_tmp38_, _tmp39_);
				_tmp40_ = cr;
				cairo_restore (_tmp40_);
				_tmp41_ = alpha;
				_tmp42_ = step;
				alpha = _tmp41_ - _tmp42_;
			}
		}
	}
	result = TRUE;
	_cairo_destroy0 (cr2);
	_cairo_surface_destroy0 (surf);
	return result;
}


ClientImage* client_image_construct (GType object_type) {
	ClientImage * self = NULL;
	self = (ClientImage*) g_object_new (object_type, NULL);
	return self;
}


ClientImage* client_image_new (void) {
	return client_image_construct (TYPE_CLIENT_IMAGE);
}


static void client_image_class_init (ClientImageClass * klass) {
	client_image_parent_class = g_type_class_peek_parent (klass);
	((GtkWidgetClass *) klass)->draw = client_image_real_draw;
}


static void client_image_instance_init (ClientImage * self) {
}


/**
 * A fancier Gtk.Image, which forces a fade-effect across the bottom of the image
 * making it easier to use/see the overlayed playback controls within the ClientWidget
 */
GType client_image_get_type (void) {
	static volatile gsize client_image_type_id__volatile = 0;
	if (g_once_init_enter (&client_image_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClientImageClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) client_image_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClientImage), 0, (GInstanceInitFunc) client_image_instance_init, NULL };
		GType client_image_type_id;
		client_image_type_id = g_type_register_static (gtk_image_get_type (), "ClientImage", &g_define_type_info, 0);
		g_once_init_leave (&client_image_type_id__volatile, client_image_type_id);
	}
	return client_image_type_id__volatile;
}


/**
     * Create a new ClientWidget
     *
     * @param client The underlying MprisClient instance to use
     */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		ClientWidget* self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->client);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static gboolean __lambda9_ (Block3Data* _data3_) {
	ClientWidget* self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = _data3_->self;
	{
		MprisClient* _tmp0_ = NULL;
		PlayerIface* _tmp1_ = NULL;
		PlayerIface* _tmp2_ = NULL;
		_tmp0_ = _data3_->client;
		_tmp1_ = mpris_client_get_player (_tmp0_);
		_tmp2_ = _tmp1_;
		mpris_iface_quit ((MprisIface*) _tmp2_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		GError* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		g_warning ("MprisGui.vala:131: Could not quit player: %s", _tmp4_);
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda9__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda9_ (self);
	return result;
}


static void ___lambda8_ (Block3Data* _data3_) {
	ClientWidget* self;
	self = _data3_->self;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda9__gsource_func, block3_data_ref (_data3_), block3_data_unref);
}


static void ____lambda8__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	___lambda8_ (self);
}


static void __lambda10_ (ClientWidget* self) {
	gboolean _tmp0_ = FALSE;
	_tmp0_ = self->priv->collapsed;
	client_widget_collapse (self, !_tmp0_);
}


static void ___lambda10__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda10_ ((ClientWidget*) self);
}


static gboolean __lambda12_ (Block3Data* _data3_) {
	ClientWidget* self;
	gboolean result = FALSE;
	MprisClient* _tmp0_ = NULL;
	PlayerIface* _tmp1_ = NULL;
	PlayerIface* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	self = _data3_->self;
	_tmp0_ = _data3_->client;
	_tmp1_ = mpris_client_get_player (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = player_iface_get_can_go_previous (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		{
			MprisClient* _tmp5_ = NULL;
			PlayerIface* _tmp6_ = NULL;
			PlayerIface* _tmp7_ = NULL;
			_tmp5_ = _data3_->client;
			_tmp6_ = mpris_client_get_player (_tmp5_);
			_tmp7_ = _tmp6_;
			player_iface_previous (_tmp7_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch7_g_error;
			}
		}
		goto __finally7;
		__catch7_g_error:
		{
			GError* e = NULL;
			GError* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = e;
			_tmp9_ = _tmp8_->message;
			g_warning ("MprisGui.vala:186: Could not go to previous track: %s", _tmp9_);
			_g_error_free0 (e);
		}
		__finally7:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda12__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda12_ (self);
	return result;
}


static void __lambda11_ (Block3Data* _data3_) {
	ClientWidget* self;
	self = _data3_->self;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda12__gsource_func, block3_data_ref (_data3_), block3_data_unref);
}


static void ___lambda11__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda11_ (self);
}


static gboolean __lambda14_ (Block3Data* _data3_) {
	ClientWidget* self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = _data3_->self;
	{
		MprisClient* _tmp0_ = NULL;
		PlayerIface* _tmp1_ = NULL;
		PlayerIface* _tmp2_ = NULL;
		_tmp0_ = _data3_->client;
		_tmp1_ = mpris_client_get_player (_tmp0_);
		_tmp2_ = _tmp1_;
		player_iface_play_pause (_tmp2_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		GError* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		g_warning ("MprisGui.vala:203: Could not play/pause: %s", _tmp4_);
		_g_error_free0 (e);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda14__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda14_ (self);
	return result;
}


static void __lambda13_ (Block3Data* _data3_) {
	ClientWidget* self;
	self = _data3_->self;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda14__gsource_func, block3_data_ref (_data3_), block3_data_unref);
}


static void ___lambda13__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda13_ (self);
}


static gboolean __lambda16_ (Block3Data* _data3_) {
	ClientWidget* self;
	gboolean result = FALSE;
	MprisClient* _tmp0_ = NULL;
	PlayerIface* _tmp1_ = NULL;
	PlayerIface* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	self = _data3_->self;
	_tmp0_ = _data3_->client;
	_tmp1_ = mpris_client_get_player (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = player_iface_get_can_go_next (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		{
			MprisClient* _tmp5_ = NULL;
			PlayerIface* _tmp6_ = NULL;
			PlayerIface* _tmp7_ = NULL;
			_tmp5_ = _data3_->client;
			_tmp6_ = mpris_client_get_player (_tmp5_);
			_tmp7_ = _tmp6_;
			player_iface_next (_tmp7_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch9_g_error;
			}
		}
		goto __finally9;
		__catch9_g_error:
		{
			GError* e = NULL;
			GError* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = e;
			_tmp9_ = _tmp8_->message;
			g_warning ("MprisGui.vala:221: Could not go to next track: %s", _tmp9_);
			_g_error_free0 (e);
		}
		__finally9:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = FALSE;
	return result;
}


static gboolean ___lambda16__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda16_ (self);
	return result;
}


static void __lambda15_ (Block3Data* _data3_) {
	ClientWidget* self;
	self = _data3_->self;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda16__gsource_func, block3_data_ref (_data3_), block3_data_unref);
}


static void ___lambda15__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda15_ (self);
}


static gboolean ___lambda19_ (ClientWidget* self) {
	gboolean result = FALSE;
	client_widget_update_from_meta (self);
	result = FALSE;
	return result;
}


static gboolean ____lambda19__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda19_ ((ClientWidget*) self);
	return result;
}


static gboolean ____lambda20_ (ClientWidget* self) {
	gboolean result = FALSE;
	client_widget_update_play_status (self);
	result = FALSE;
	return result;
}


static gboolean _____lambda20__gsource_func (gpointer self) {
	gboolean result;
	result = ____lambda20_ ((ClientWidget*) self);
	return result;
}


static gboolean _____lambda21_ (ClientWidget* self) {
	gboolean result = FALSE;
	client_widget_update_controls (self);
	result = FALSE;
	return result;
}


static gboolean ______lambda21__gsource_func (gpointer self) {
	gboolean result;
	result = _____lambda21_ ((ClientWidget*) self);
	return result;
}


static void ___lambda18_ (ClientWidget* self, const gchar* k, GVariant* v) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (k != NULL);
	g_return_if_fail (v != NULL);
	_tmp0_ = k;
	if (g_strcmp0 (_tmp0_, "Metadata") == 0) {
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ____lambda19__gsource_func, g_object_ref (self), g_object_unref);
	} else {
		const gchar* _tmp1_ = NULL;
		_tmp1_ = k;
		if (g_strcmp0 (_tmp1_, "PlaybackStatus") == 0) {
			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _____lambda20__gsource_func, g_object_ref (self), g_object_unref);
		} else {
			gboolean _tmp2_ = FALSE;
			const gchar* _tmp3_ = NULL;
			_tmp3_ = k;
			if (g_strcmp0 (_tmp3_, "CanGoNext") == 0) {
				_tmp2_ = TRUE;
			} else {
				const gchar* _tmp4_ = NULL;
				_tmp4_ = k;
				_tmp2_ = g_strcmp0 (_tmp4_, "CanGoPrevious") == 0;
			}
			if (_tmp2_) {
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ______lambda21__gsource_func, g_object_ref (self), g_object_unref);
			}
		}
	}
}


static void ____lambda18__gh_func (gconstpointer key, gconstpointer value, gpointer self) {
	___lambda18_ ((ClientWidget*) self, (const gchar*) key, (GVariant*) value);
}


static void __lambda17_ (ClientWidget* self, const gchar* i, GHashTable* p, gchar** inv, int inv_length1) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (i != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = i;
	if (g_strcmp0 (_tmp0_, "org.mpris.MediaPlayer2.Player") == 0) {
		GHashTable* _tmp1_ = NULL;
		_tmp1_ = p;
		g_hash_table_foreach (_tmp1_, ____lambda18__gh_func, self);
	}
}


static void ___lambda17__dbus_prop_iface_properties_changed (DbusPropIface* _sender, const gchar* iface, GHashTable* changed, gchar** invalid, int invalid_length1, gpointer self) {
	__lambda17_ ((ClientWidget*) self, iface, changed, invalid, invalid_length1);
}


ClientWidget* client_widget_construct (GType object_type, MprisClient* client) {
	ClientWidget * self = NULL;
	Block3Data* _data3_;
	MprisClient* _tmp0_ = NULL;
	MprisClient* _tmp1_ = NULL;
	MprisClient* _tmp2_ = NULL;
	MprisClient* _tmp3_ = NULL;
	GtkRevealer* _tmp4_ = NULL;
	GtkRevealer* _tmp5_ = NULL;
	GtkBox* player_box = NULL;
	GtkBox* _tmp6_ = NULL;
	GtkWidget* row = NULL;
	gchar* icon_name = NULL;
	gchar* _tmp7_ = NULL;
	MprisClient* _tmp8_ = NULL;
	PlayerIface* _tmp9_ = NULL;
	PlayerIface* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gboolean _tmp14_ = FALSE;
	GtkWidget* _tmp33_ = NULL;
	GtkWidget* _tmp42_ = NULL;
	GtkWidget* _tmp43_ = NULL;
	MprisClient* _tmp44_ = NULL;
	PlayerIface* _tmp45_ = NULL;
	PlayerIface* _tmp46_ = NULL;
	gboolean _tmp47_ = FALSE;
	gboolean _tmp48_ = FALSE;
	GtkButton* _tmp54_ = NULL;
	GtkButton* _tmp55_ = NULL;
	GtkButton* _tmp56_ = NULL;
	GtkWidget* _tmp57_ = NULL;
	GtkButton* _tmp58_ = NULL;
	ClientImage* _tmp59_ = NULL;
	GtkImage* _tmp60_ = NULL;
	GtkOverlay* layout = NULL;
	GtkOverlay* _tmp61_ = NULL;
	GtkBox* _tmp62_ = NULL;
	GtkImage* _tmp63_ = NULL;
	GtkWidget* _tmp64_ = NULL;
	GtkWidget* _tmp65_ = NULL;
	gconstpointer _tmp66_ = NULL;
	GtkLabel* _tmp67_ = NULL;
	GtkBox* _tmp68_ = NULL;
	GtkWidget* _tmp69_ = NULL;
	GtkWidget* _tmp70_ = NULL;
	GtkWidget* _tmp71_ = NULL;
	gconstpointer _tmp72_ = NULL;
	GtkLabel* _tmp73_ = NULL;
	GtkBox* _tmp74_ = NULL;
	GtkWidget* _tmp75_ = NULL;
	GtkWidget* _tmp76_ = NULL;
	GtkWidget* _tmp77_ = NULL;
	gconstpointer _tmp78_ = NULL;
	GtkLabel* _tmp79_ = NULL;
	GtkBox* _tmp80_ = NULL;
	GtkWidget* _tmp81_ = NULL;
	GtkBox* controls = NULL;
	GtkBox* _tmp82_ = NULL;
	GtkButton* btn = NULL;
	GtkButton* _tmp83_ = NULL;
	GtkButton* _tmp84_ = NULL;
	GtkButton* _tmp85_ = NULL;
	GtkButton* _tmp86_ = NULL;
	GtkButton* _tmp87_ = NULL;
	GtkButton* _tmp88_ = NULL;
	GtkButton* _tmp89_ = NULL;
	GtkButton* _tmp90_ = NULL;
	GtkButton* _tmp91_ = NULL;
	GtkButton* _tmp92_ = NULL;
	GtkButton* _tmp93_ = NULL;
	GtkButton* _tmp94_ = NULL;
	GtkButton* _tmp95_ = NULL;
	GtkButton* _tmp96_ = NULL;
	GtkButton* _tmp97_ = NULL;
	GtkButton* _tmp98_ = NULL;
	GtkButton* _tmp99_ = NULL;
	GtkButton* _tmp100_ = NULL;
	GtkButton* _tmp101_ = NULL;
	GtkButton* _tmp102_ = NULL;
	GtkButton* _tmp103_ = NULL;
	GtkButton* _tmp104_ = NULL;
	GtkButton* _tmp105_ = NULL;
	MprisClient* _tmp106_ = NULL;
	DbusPropIface* _tmp107_ = NULL;
	DbusPropIface* _tmp108_ = NULL;
	GtkRevealer* _tmp109_ = NULL;
	GtkBox* _tmp110_ = NULL;
	GtkRevealer* _tmp111_ = NULL;
	g_return_val_if_fail (client != NULL, NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_tmp0_ = client;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data3_->client);
	_data3_->client = _tmp1_;
	self = (ClientWidget*) g_object_new (object_type, "orientation", GTK_ORIENTATION_VERTICAL, "spacing", 3, NULL);
	_data3_->self = g_object_ref (self);
	_tmp2_ = _data3_->client;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->client);
	self->priv->client = _tmp3_;
	_tmp4_ = (GtkRevealer*) gtk_revealer_new ();
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->player_revealer);
	self->priv->player_revealer = _tmp4_;
	_tmp5_ = self->priv->player_revealer;
	gtk_revealer_set_reveal_child (_tmp5_, TRUE);
	_tmp6_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 3);
	g_object_ref_sink (_tmp6_);
	player_box = _tmp6_;
	row = NULL;
	_tmp7_ = g_strdup ("emblem-music-symbolic");
	icon_name = _tmp7_;
	_tmp8_ = _data3_->client;
	_tmp9_ = mpris_client_get_player (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = mpris_iface_get_desktop_entry ((MprisIface*) _tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = _tmp12_;
	_tmp14_ = g_strcmp0 (_tmp13_, "") != 0;
	_g_free0 (_tmp13_);
	if (_tmp14_) {
		GDesktopAppInfo* ainfo = NULL;
		MprisClient* _tmp15_ = NULL;
		PlayerIface* _tmp16_ = NULL;
		PlayerIface* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		GDesktopAppInfo* _tmp23_ = NULL;
		GDesktopAppInfo* _tmp24_ = NULL;
		GDesktopAppInfo* _tmp25_ = NULL;
		_tmp15_ = _data3_->client;
		_tmp16_ = mpris_client_get_player (_tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = mpris_iface_get_desktop_entry ((MprisIface*) _tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = _tmp19_;
		_tmp21_ = g_strconcat (_tmp20_, ".desktop", NULL);
		_tmp22_ = _tmp21_;
		_tmp23_ = g_desktop_app_info_new (_tmp22_);
		_tmp24_ = _tmp23_;
		_g_free0 (_tmp22_);
		_g_free0 (_tmp20_);
		ainfo = _tmp24_;
		_tmp25_ = ainfo;
		if (_tmp25_ != NULL) {
			GIcon* icon = NULL;
			GDesktopAppInfo* _tmp26_ = NULL;
			GIcon* _tmp27_ = NULL;
			GIcon* _tmp28_ = NULL;
			GDesktopAppInfo* _tmp29_ = NULL;
			const gchar* _tmp30_ = NULL;
			GIcon* _tmp31_ = NULL;
			GtkWidget* _tmp32_ = NULL;
			_tmp26_ = ainfo;
			_tmp27_ = g_app_info_get_icon ((GAppInfo*) _tmp26_);
			_tmp28_ = _g_object_ref0 (_tmp27_);
			icon = _tmp28_;
			_tmp29_ = ainfo;
			_tmp30_ = g_app_info_get_display_name ((GAppInfo*) _tmp29_);
			_tmp31_ = icon;
			_tmp32_ = create_row (_tmp30_, NULL, _tmp31_);
			_g_object_unref0 (row);
			row = _tmp32_;
			_g_object_unref0 (icon);
		}
		_g_object_unref0 (ainfo);
	}
	_tmp33_ = row;
	if (_tmp33_ == NULL) {
		MprisClient* _tmp34_ = NULL;
		PlayerIface* _tmp35_ = NULL;
		PlayerIface* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		const gchar* _tmp40_ = NULL;
		GtkWidget* _tmp41_ = NULL;
		_tmp34_ = _data3_->client;
		_tmp35_ = mpris_client_get_player (_tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = mpris_iface_get_identity ((MprisIface*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = _tmp38_;
		_tmp40_ = icon_name;
		_tmp41_ = create_row (_tmp39_, _tmp40_, NULL);
		_g_object_unref0 (row);
		row = _tmp41_;
		_g_free0 (_tmp39_);
	}
	_tmp42_ = row;
	gtk_widget_set_margin_bottom (_tmp42_, 3);
	_tmp43_ = row;
	gtk_box_pack_start ((GtkBox*) self, _tmp43_, FALSE, FALSE, (guint) 0);
	_tmp44_ = _data3_->client;
	_tmp45_ = mpris_client_get_player (_tmp44_);
	_tmp46_ = _tmp45_;
	_tmp47_ = mpris_iface_get_can_quit ((MprisIface*) _tmp46_);
	_tmp48_ = _tmp47_;
	if (_tmp48_) {
		GtkButton* qbtn = NULL;
		GtkButton* _tmp49_ = NULL;
		GtkButton* _tmp50_ = NULL;
		GtkButton* _tmp51_ = NULL;
		GtkWidget* _tmp52_ = NULL;
		GtkButton* _tmp53_ = NULL;
		_tmp49_ = (GtkButton*) gtk_button_new_from_icon_name ("window-close-symbolic", GTK_ICON_SIZE_MENU);
		g_object_ref_sink (_tmp49_);
		qbtn = _tmp49_;
		_tmp50_ = qbtn;
		g_signal_connect_data (_tmp50_, "clicked", (GCallback) ____lambda8__gtk_button_clicked, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
		_tmp51_ = qbtn;
		gtk_button_set_relief (_tmp51_, GTK_RELIEF_NONE);
		_tmp52_ = row;
		_tmp53_ = qbtn;
		gtk_box_pack_end (G_TYPE_CHECK_INSTANCE_TYPE (_tmp52_, gtk_box_get_type ()) ? ((GtkBox*) _tmp52_) : NULL, (GtkWidget*) _tmp53_, FALSE, FALSE, (guint) 0);
		_g_object_unref0 (qbtn);
	} else {
		client_widget_collapse (self, TRUE);
	}
	_tmp54_ = (GtkButton*) gtk_button_new_from_icon_name ("window-minimize-symbolic", GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp54_);
	_g_object_unref0 (self->priv->collapse_btn);
	self->priv->collapse_btn = _tmp54_;
	_tmp55_ = self->priv->collapse_btn;
	g_signal_connect_object (_tmp55_, "clicked", (GCallback) ___lambda10__gtk_button_clicked, self, 0);
	_tmp56_ = self->priv->collapse_btn;
	gtk_button_set_relief (_tmp56_, GTK_RELIEF_NONE);
	_tmp57_ = row;
	_tmp58_ = self->priv->collapse_btn;
	gtk_box_pack_end (G_TYPE_CHECK_INSTANCE_TYPE (_tmp57_, gtk_box_get_type ()) ? ((GtkBox*) _tmp57_) : NULL, (GtkWidget*) _tmp58_, FALSE, FALSE, (guint) 0);
	_tmp59_ = client_image_new_from_icon_name ("emblem-music-symbolic", GTK_ICON_SIZE_INVALID);
	g_object_ref_sink (_tmp59_);
	_g_object_unref0 (self->priv->background);
	self->priv->background = (GtkImage*) _tmp59_;
	_tmp60_ = self->priv->background;
	gtk_image_set_pixel_size (_tmp60_, BACKGROUND_SIZE);
	_tmp61_ = (GtkOverlay*) gtk_overlay_new ();
	g_object_ref_sink (_tmp61_);
	layout = _tmp61_;
	_tmp62_ = player_box;
	gtk_box_pack_start (_tmp62_, (GtkWidget*) layout, TRUE, TRUE, (guint) 0);
	_tmp63_ = self->priv->background;
	gtk_container_add ((GtkContainer*) layout, (GtkWidget*) _tmp63_);
	_tmp64_ = create_row ("Unknown Artist", "user-info-symbolic", NULL);
	_g_object_unref0 (row);
	row = _tmp64_;
	_tmp65_ = row;
	_tmp66_ = g_object_get_data ((GObject*) _tmp65_, "label_item");
	_tmp67_ = _g_object_ref0 ((GtkLabel*) _tmp66_);
	_g_object_unref0 (self->priv->artist_label);
	self->priv->artist_label = _tmp67_;
	_tmp68_ = player_box;
	_tmp69_ = row;
	gtk_box_pack_start (_tmp68_, _tmp69_, FALSE, FALSE, (guint) 0);
	_tmp70_ = create_row ("Unknown Title", "emblem-music-symbolic", NULL);
	_g_object_unref0 (row);
	row = _tmp70_;
	_tmp71_ = row;
	_tmp72_ = g_object_get_data ((GObject*) _tmp71_, "label_item");
	_tmp73_ = _g_object_ref0 ((GtkLabel*) _tmp72_);
	_g_object_unref0 (self->priv->title_label);
	self->priv->title_label = _tmp73_;
	_tmp74_ = player_box;
	_tmp75_ = row;
	gtk_box_pack_start (_tmp74_, _tmp75_, FALSE, FALSE, (guint) 0);
	_tmp76_ = create_row ("Unknown Album", "media-optical-symbolic", NULL);
	_g_object_unref0 (row);
	row = _tmp76_;
	_tmp77_ = row;
	_tmp78_ = g_object_get_data ((GObject*) _tmp77_, "label_item");
	_tmp79_ = _g_object_ref0 ((GtkLabel*) _tmp78_);
	_g_object_unref0 (self->priv->album_label);
	self->priv->album_label = _tmp79_;
	_tmp80_ = player_box;
	_tmp81_ = row;
	gtk_box_pack_start (_tmp80_, _tmp81_, FALSE, FALSE, (guint) 0);
	_tmp82_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp82_);
	controls = _tmp82_;
	_tmp83_ = (GtkButton*) gtk_button_new_from_icon_name ("media-skip-backward-symbolic", GTK_ICON_SIZE_LARGE_TOOLBAR);
	g_object_ref_sink (_tmp83_);
	btn = _tmp83_;
	_tmp84_ = btn;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp84_, FALSE);
	_tmp85_ = btn;
	gtk_widget_set_can_focus ((GtkWidget*) _tmp85_, FALSE);
	_tmp86_ = btn;
	_tmp87_ = _g_object_ref0 (_tmp86_);
	_g_object_unref0 (self->priv->prev_btn);
	self->priv->prev_btn = _tmp87_;
	_tmp88_ = btn;
	g_signal_connect_data (_tmp88_, "clicked", (GCallback) ___lambda11__gtk_button_clicked, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_tmp89_ = btn;
	gtk_button_set_relief (_tmp89_, GTK_RELIEF_NONE);
	_tmp90_ = btn;
	gtk_box_pack_start (controls, (GtkWidget*) _tmp90_, FALSE, FALSE, (guint) 0);
	_tmp91_ = (GtkButton*) gtk_button_new_from_icon_name ("media-playback-start-symbolic", GTK_ICON_SIZE_LARGE_TOOLBAR);
	g_object_ref_sink (_tmp91_);
	_g_object_unref0 (btn);
	btn = _tmp91_;
	_tmp92_ = btn;
	_tmp93_ = _g_object_ref0 (_tmp92_);
	_g_object_unref0 (self->priv->play_btn);
	self->priv->play_btn = _tmp93_;
	_tmp94_ = btn;
	gtk_widget_set_can_focus ((GtkWidget*) _tmp94_, FALSE);
	_tmp95_ = btn;
	g_signal_connect_data (_tmp95_, "clicked", (GCallback) ___lambda13__gtk_button_clicked, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_tmp96_ = btn;
	gtk_button_set_relief (_tmp96_, GTK_RELIEF_NONE);
	_tmp97_ = btn;
	gtk_box_pack_start (controls, (GtkWidget*) _tmp97_, FALSE, FALSE, (guint) 0);
	_tmp98_ = (GtkButton*) gtk_button_new_from_icon_name ("media-skip-forward-symbolic", GTK_ICON_SIZE_LARGE_TOOLBAR);
	g_object_ref_sink (_tmp98_);
	_g_object_unref0 (btn);
	btn = _tmp98_;
	_tmp99_ = btn;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp99_, FALSE);
	_tmp100_ = btn;
	gtk_widget_set_can_focus ((GtkWidget*) _tmp100_, FALSE);
	_tmp101_ = btn;
	_tmp102_ = _g_object_ref0 (_tmp101_);
	_g_object_unref0 (self->priv->next_btn);
	self->priv->next_btn = _tmp102_;
	_tmp103_ = btn;
	g_signal_connect_data (_tmp103_, "clicked", (GCallback) ___lambda15__gtk_button_clicked, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_tmp104_ = btn;
	gtk_button_set_relief (_tmp104_, GTK_RELIEF_NONE);
	_tmp105_ = btn;
	gtk_box_pack_start (controls, (GtkWidget*) _tmp105_, FALSE, FALSE, (guint) 0);
	gtk_widget_set_halign ((GtkWidget*) controls, GTK_ALIGN_CENTER);
	gtk_widget_set_valign ((GtkWidget*) controls, GTK_ALIGN_END);
	gtk_widget_set_margin_bottom ((GtkWidget*) controls, (gint) (200 * 0.10));
	gtk_overlay_add_overlay (layout, (GtkWidget*) controls);
	client_widget_update_from_meta (self);
	client_widget_update_play_status (self);
	client_widget_update_controls (self);
	_tmp106_ = _data3_->client;
	_tmp107_ = mpris_client_get_prop (_tmp106_);
	_tmp108_ = _tmp107_;
	g_signal_connect_object (_tmp108_, "properties-changed", (GCallback) ___lambda17__dbus_prop_iface_properties_changed, self, 0);
	_tmp109_ = self->priv->player_revealer;
	_tmp110_ = player_box;
	gtk_container_add ((GtkContainer*) _tmp109_, (GtkWidget*) _tmp110_);
	_tmp111_ = self->priv->player_revealer;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp111_, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (btn);
	_g_object_unref0 (controls);
	_g_object_unref0 (layout);
	_g_free0 (icon_name);
	_g_object_unref0 (row);
	_g_object_unref0 (player_box);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return self;
}


ClientWidget* client_widget_new (MprisClient* client) {
	return client_widget_construct (TYPE_CLIENT_WIDGET, client);
}


static void client_widget_collapse (ClientWidget* self, gboolean collapse) {
	GtkRevealer* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp7_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->player_revealer;
	_tmp1_ = collapse;
	gtk_revealer_set_reveal_child (_tmp0_, !_tmp1_);
	_tmp2_ = collapse;
	if (_tmp2_) {
		GtkButton* _tmp3_ = NULL;
		GtkWidget* _tmp4_ = NULL;
		_tmp3_ = self->priv->collapse_btn;
		_tmp4_ = gtk_button_get_image (_tmp3_);
		gtk_image_set_from_icon_name (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, gtk_image_get_type ()) ? ((GtkImage*) _tmp4_) : NULL, "window-maximize-symbolic", GTK_ICON_SIZE_MENU);
	} else {
		GtkButton* _tmp5_ = NULL;
		GtkWidget* _tmp6_ = NULL;
		_tmp5_ = self->priv->collapse_btn;
		_tmp6_ = gtk_button_get_image (_tmp5_);
		gtk_image_set_from_icon_name (G_TYPE_CHECK_INSTANCE_TYPE (_tmp6_, gtk_image_get_type ()) ? ((GtkImage*) _tmp6_) : NULL, "window-minimize-symbolic", GTK_ICON_SIZE_MENU);
	}
	_tmp7_ = collapse;
	self->priv->collapsed = _tmp7_;
}


/**
     * Update play status based on player requirements
     */
static void client_widget_update_play_status (ClientWidget* self) {
	MprisClient* _tmp0_ = NULL;
	PlayerIface* _tmp1_ = NULL;
	PlayerIface* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	GQuark _tmp7_ = 0U;
	static GQuark _tmp6_label0 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->client;
	_tmp1_ = mpris_client_get_player (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = player_iface_get_playback_status (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_tmp7_ = (NULL == _tmp5_) ? 0 : g_quark_from_string (_tmp5_);
	g_free (_tmp5_);
	if (_tmp7_ == ((0 != _tmp6_label0) ? _tmp6_label0 : (_tmp6_label0 = g_quark_from_static_string ("Playing")))) {
		switch (0) {
			default:
			{
				GtkButton* _tmp8_ = NULL;
				GtkWidget* _tmp9_ = NULL;
				_tmp8_ = self->priv->play_btn;
				_tmp9_ = gtk_button_get_image (_tmp8_);
				gtk_image_set_from_icon_name (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, gtk_image_get_type ()) ? ((GtkImage*) _tmp9_) : NULL, "media-playback-pause-symbolic", GTK_ICON_SIZE_LARGE_TOOLBAR);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				GtkButton* _tmp10_ = NULL;
				GtkWidget* _tmp11_ = NULL;
				_tmp10_ = self->priv->play_btn;
				_tmp11_ = gtk_button_get_image (_tmp10_);
				gtk_image_set_from_icon_name (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, gtk_image_get_type ()) ? ((GtkImage*) _tmp11_) : NULL, "media-playback-start-symbolic", GTK_ICON_SIZE_LARGE_TOOLBAR);
				break;
			}
		}
	}
}


/**
     * Update prev/next sensitivity based on player requirements
     */
static void client_widget_update_controls (ClientWidget* self) {
	GtkButton* _tmp0_ = NULL;
	MprisClient* _tmp1_ = NULL;
	PlayerIface* _tmp2_ = NULL;
	PlayerIface* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	GtkButton* _tmp6_ = NULL;
	MprisClient* _tmp7_ = NULL;
	PlayerIface* _tmp8_ = NULL;
	PlayerIface* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->prev_btn;
	_tmp1_ = self->priv->client;
	_tmp2_ = mpris_client_get_player (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = player_iface_get_can_go_previous (_tmp3_);
	_tmp5_ = _tmp4_;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp0_, _tmp5_);
	_tmp6_ = self->priv->next_btn;
	_tmp7_ = self->priv->client;
	_tmp8_ = mpris_client_get_player (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = player_iface_get_can_go_next (_tmp9_);
	_tmp11_ = _tmp10_;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp6_, _tmp11_);
}


/**
     * Utility, handle updating the album art
     */
static void client_widget_update_art (ClientWidget* self, const gchar* uri) {
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gchar* fname = NULL;
	const gchar* _tmp4_ = NULL;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_ = NULL;
	gchar** _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (uri != NULL);
	_tmp0_ = uri;
	_tmp1_ = g_str_has_prefix (_tmp0_, "file://");
	if (!_tmp1_) {
		GtkImage* _tmp2_ = NULL;
		GtkImage* _tmp3_ = NULL;
		_tmp2_ = self->priv->background;
		gtk_image_set_from_icon_name (_tmp2_, "emblem-music-symbolic", GTK_ICON_SIZE_INVALID);
		_tmp3_ = self->priv->background;
		gtk_image_set_pixel_size (_tmp3_, BACKGROUND_SIZE);
		return;
	}
	_tmp4_ = uri;
	_tmp6_ = _tmp5_ = g_strsplit (_tmp4_, "file://", 0);
	_tmp7_ = _tmp6_;
	_tmp7__length1 = _vala_array_length (_tmp5_);
	_tmp8_ = _tmp7_[1];
	_tmp9_ = g_strdup (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp7_ = (_vala_array_free (_tmp7_, _tmp7__length1, (GDestroyNotify) g_free), NULL);
	fname = _tmp10_;
	{
		GdkPixbuf* pbuf = NULL;
		const gchar* _tmp11_ = NULL;
		GdkPixbuf* _tmp12_ = NULL;
		GtkImage* _tmp13_ = NULL;
		GdkPixbuf* _tmp14_ = NULL;
		_tmp11_ = fname;
		_tmp12_ = gdk_pixbuf_new_from_file_at_size (_tmp11_, BACKGROUND_SIZE, BACKGROUND_SIZE, &_inner_error_);
		pbuf = _tmp12_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch10_g_error;
		}
		_tmp13_ = self->priv->background;
		_tmp14_ = pbuf;
		gtk_image_set_from_pixbuf (_tmp13_, _tmp14_);
		_g_object_unref0 (pbuf);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError* e = NULL;
		GtkImage* _tmp15_ = NULL;
		GtkImage* _tmp16_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp15_ = self->priv->background;
		gtk_image_set_from_icon_name (_tmp15_, "emblem-music-symbolic", GTK_ICON_SIZE_INVALID);
		_tmp16_ = self->priv->background;
		gtk_image_set_pixel_size (_tmp16_, BACKGROUND_SIZE);
		_g_error_free0 (e);
	}
	__finally10:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (fname);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (fname);
}


/**
     * Update display info such as artist, the background image, etc.
     */
static gchar* _vala_g_strjoinv (const gchar* separator, gchar** str_array, int str_array_length1) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = separator;
	if (_tmp0_ == NULL) {
		separator = "";
	}
	_tmp3_ = str_array;
	_tmp3__length1 = str_array_length1;
	if (_tmp3_ != NULL) {
		_tmp2_ = TRUE;
	} else {
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp4_ = str_array;
		_tmp4__length1 = str_array_length1;
		_tmp2_ = _tmp4__length1 > 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		_tmp6_ = str_array;
		_tmp6__length1 = str_array_length1;
		if (_tmp6__length1 == -1) {
			gchar** _tmp7_ = NULL;
			gint _tmp7__length1 = 0;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = str_array;
			_tmp7__length1 = str_array_length1;
			_tmp8_ = _tmp7_[0];
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp1_ = _tmp5_;
	}
	if (_tmp1_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp31_ = 0;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gsize _tmp35_ = 0UL;
		const gchar* _tmp36_ = NULL;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		const gchar* res = NULL;
		gsize _tmp40_ = 0UL;
		void* _tmp41_ = NULL;
		void* ptr = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gint _tmp43__length1 = 0;
		const gchar* _tmp44_ = NULL;
		void* _tmp45_ = NULL;
		const gchar* _tmp62_ = NULL;
		len = (gsize) 1;
		{
			gboolean _tmp9_ = FALSE;
			i = 0;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				gchar** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp21_ = 0;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gint _tmp23_ = 0;
				const gchar* _tmp24_ = NULL;
				gsize _tmp30_ = 0UL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp13_ = str_array;
				_tmp13__length1 = str_array_length1;
				if (_tmp13__length1 != -1) {
					gint _tmp14_ = 0;
					gchar** _tmp15_ = NULL;
					gint _tmp15__length1 = 0;
					_tmp14_ = i;
					_tmp15_ = str_array;
					_tmp15__length1 = str_array_length1;
					_tmp12_ = _tmp14_ < _tmp15__length1;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					_tmp11_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					_tmp17_ = str_array;
					_tmp17__length1 = str_array_length1;
					if (_tmp17__length1 == -1) {
						gchar** _tmp18_ = NULL;
						gint _tmp18__length1 = 0;
						gint _tmp19_ = 0;
						const gchar* _tmp20_ = NULL;
						_tmp18_ = str_array;
						_tmp18__length1 = str_array_length1;
						_tmp19_ = i;
						_tmp20_ = _tmp18_[_tmp19_];
						_tmp16_ = _tmp20_ != NULL;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp11_ = _tmp16_;
				}
				if (!_tmp11_) {
					break;
				}
				_tmp22_ = str_array;
				_tmp22__length1 = str_array_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				if (_tmp24_ != NULL) {
					gchar** _tmp25_ = NULL;
					gint _tmp25__length1 = 0;
					gint _tmp26_ = 0;
					const gchar* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					_tmp25_ = str_array;
					_tmp25__length1 = str_array_length1;
					_tmp26_ = i;
					_tmp27_ = _tmp25_[_tmp26_];
					_tmp28_ = strlen ((const gchar*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp21_ = _tmp29_;
				} else {
					_tmp21_ = 0;
				}
				_tmp30_ = len;
				len = _tmp30_ + _tmp21_;
			}
		}
		_tmp31_ = i;
		if (_tmp31_ == 0) {
			gchar* _tmp32_ = NULL;
			_tmp32_ = g_strdup ("");
			result = _tmp32_;
			return result;
		}
		_tmp33_ = i;
		str_array_length1 = _tmp33_;
		_tmp34_ = str_array_length1;
		_tmp35_ = len;
		_tmp36_ = separator;
		_tmp37_ = strlen ((const gchar*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = i;
		len = _tmp35_ + (_tmp38_ * (_tmp39_ - 1));
		_tmp40_ = len;
		_tmp41_ = g_malloc (_tmp40_);
		res = _tmp41_;
		_tmp42_ = res;
		_tmp43_ = str_array;
		_tmp43__length1 = str_array_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_stpcpy ((void*) _tmp42_, (const gchar*) _tmp44_);
		ptr = _tmp45_;
		{
			gboolean _tmp46_ = FALSE;
			i = 1;
			_tmp46_ = TRUE;
			while (TRUE) {
				gint _tmp48_ = 0;
				gchar** _tmp49_ = NULL;
				gint _tmp49__length1 = 0;
				void* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				void* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				gchar** _tmp54_ = NULL;
				gint _tmp54__length1 = 0;
				gint _tmp55_ = 0;
				const gchar* _tmp56_ = NULL;
				void* _tmp60_ = NULL;
				void* _tmp61_ = NULL;
				if (!_tmp46_) {
					gint _tmp47_ = 0;
					_tmp47_ = i;
					i = _tmp47_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp48_ = i;
				_tmp49_ = str_array;
				_tmp49__length1 = str_array_length1;
				if (!(_tmp48_ < _tmp49__length1)) {
					break;
				}
				_tmp50_ = ptr;
				_tmp51_ = separator;
				_tmp52_ = g_stpcpy (_tmp50_, (const gchar*) _tmp51_);
				ptr = _tmp52_;
				_tmp54_ = str_array;
				_tmp54__length1 = str_array_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_];
				if (_tmp56_ != NULL) {
					gchar** _tmp57_ = NULL;
					gint _tmp57__length1 = 0;
					gint _tmp58_ = 0;
					const gchar* _tmp59_ = NULL;
					_tmp57_ = str_array;
					_tmp57__length1 = str_array_length1;
					_tmp58_ = i;
					_tmp59_ = _tmp57_[_tmp58_];
					_tmp53_ = (const gchar*) _tmp59_;
				} else {
					_tmp53_ = "";
				}
				_tmp60_ = ptr;
				_tmp61_ = g_stpcpy (_tmp60_, _tmp53_);
				ptr = _tmp61_;
			}
		}
		_tmp62_ = res;
		res = NULL;
		result = (gchar*) _tmp62_;
		return result;
	} else {
		gchar* _tmp63_ = NULL;
		_tmp63_ = g_strdup ("");
		result = _tmp63_;
		return result;
	}
}


void client_widget_update_from_meta (ClientWidget* self) {
	MprisClient* _tmp0_ = NULL;
	PlayerIface* _tmp1_ = NULL;
	PlayerIface* _tmp2_ = NULL;
	GHashTable* _tmp3_ = NULL;
	GHashTable* _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	MprisClient* _tmp21_ = NULL;
	PlayerIface* _tmp22_ = NULL;
	PlayerIface* _tmp23_ = NULL;
	GHashTable* _tmp24_ = NULL;
	GHashTable* _tmp25_ = NULL;
	GHashTable* _tmp26_ = NULL;
	gboolean _tmp27_ = FALSE;
	gboolean _tmp28_ = FALSE;
	MprisClient* _tmp39_ = NULL;
	PlayerIface* _tmp40_ = NULL;
	PlayerIface* _tmp41_ = NULL;
	GHashTable* _tmp42_ = NULL;
	GHashTable* _tmp43_ = NULL;
	GHashTable* _tmp44_ = NULL;
	gboolean _tmp45_ = FALSE;
	gboolean _tmp46_ = FALSE;
	MprisClient* _tmp62_ = NULL;
	PlayerIface* _tmp63_ = NULL;
	PlayerIface* _tmp64_ = NULL;
	GHashTable* _tmp65_ = NULL;
	GHashTable* _tmp66_ = NULL;
	GHashTable* _tmp67_ = NULL;
	gboolean _tmp68_ = FALSE;
	gboolean _tmp69_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->client;
	_tmp1_ = mpris_client_get_player (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = player_iface_get_metadata (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_tmp6_ = g_hash_table_contains (_tmp5_, "mpris:artUrl");
	_tmp7_ = _tmp6_;
	_g_hash_table_unref0 (_tmp5_);
	if (_tmp7_) {
		gchar* url = NULL;
		MprisClient* _tmp8_ = NULL;
		PlayerIface* _tmp9_ = NULL;
		PlayerIface* _tmp10_ = NULL;
		GHashTable* _tmp11_ = NULL;
		GHashTable* _tmp12_ = NULL;
		GHashTable* _tmp13_ = NULL;
		gconstpointer _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		_tmp8_ = self->priv->client;
		_tmp9_ = mpris_client_get_player (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = player_iface_get_metadata (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = _tmp12_;
		_tmp14_ = g_hash_table_lookup (_tmp13_, "mpris:artUrl");
		_tmp15_ = g_variant_get_string ((GVariant*) _tmp14_, NULL);
		_tmp16_ = g_strdup (_tmp15_);
		_tmp17_ = _tmp16_;
		_g_hash_table_unref0 (_tmp13_);
		url = _tmp17_;
		_tmp18_ = url;
		client_widget_update_art (self, _tmp18_);
		_g_free0 (url);
	} else {
		GtkImage* _tmp19_ = NULL;
		GtkImage* _tmp20_ = NULL;
		_tmp19_ = self->priv->background;
		gtk_image_set_pixel_size (_tmp19_, BACKGROUND_SIZE);
		_tmp20_ = self->priv->background;
		gtk_image_set_from_icon_name (_tmp20_, "emblem-music-symbolic", GTK_ICON_SIZE_INVALID);
	}
	_tmp21_ = self->priv->client;
	_tmp22_ = mpris_client_get_player (_tmp21_);
	_tmp23_ = _tmp22_;
	_tmp24_ = player_iface_get_metadata (_tmp23_);
	_tmp25_ = _tmp24_;
	_tmp26_ = _tmp25_;
	_tmp27_ = g_hash_table_contains (_tmp26_, "xesam:title");
	_tmp28_ = _tmp27_;
	_g_hash_table_unref0 (_tmp26_);
	if (_tmp28_) {
		GtkLabel* _tmp29_ = NULL;
		MprisClient* _tmp30_ = NULL;
		PlayerIface* _tmp31_ = NULL;
		PlayerIface* _tmp32_ = NULL;
		GHashTable* _tmp33_ = NULL;
		GHashTable* _tmp34_ = NULL;
		GHashTable* _tmp35_ = NULL;
		gconstpointer _tmp36_ = NULL;
		const gchar* _tmp37_ = NULL;
		_tmp29_ = self->priv->title_label;
		_tmp30_ = self->priv->client;
		_tmp31_ = mpris_client_get_player (_tmp30_);
		_tmp32_ = _tmp31_;
		_tmp33_ = player_iface_get_metadata (_tmp32_);
		_tmp34_ = _tmp33_;
		_tmp35_ = _tmp34_;
		_tmp36_ = g_hash_table_lookup (_tmp35_, "xesam:title");
		_tmp37_ = g_variant_get_string ((GVariant*) _tmp36_, NULL);
		gtk_label_set_text (_tmp29_, _tmp37_);
		_g_hash_table_unref0 (_tmp35_);
	} else {
		GtkLabel* _tmp38_ = NULL;
		_tmp38_ = self->priv->title_label;
		gtk_label_set_text (_tmp38_, "Unknown Title");
	}
	_tmp39_ = self->priv->client;
	_tmp40_ = mpris_client_get_player (_tmp39_);
	_tmp41_ = _tmp40_;
	_tmp42_ = player_iface_get_metadata (_tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = _tmp43_;
	_tmp45_ = g_hash_table_contains (_tmp44_, "xesam:artist");
	_tmp46_ = _tmp45_;
	_g_hash_table_unref0 (_tmp44_);
	if (_tmp46_) {
		gchar** artists = NULL;
		MprisClient* _tmp47_ = NULL;
		PlayerIface* _tmp48_ = NULL;
		PlayerIface* _tmp49_ = NULL;
		GHashTable* _tmp50_ = NULL;
		GHashTable* _tmp51_ = NULL;
		GHashTable* _tmp52_ = NULL;
		gconstpointer _tmp53_ = NULL;
		size_t _tmp54_;
		gchar** _tmp55_ = NULL;
		gchar** _tmp56_ = NULL;
		gint _tmp56__length1 = 0;
		gint artists_length1 = 0;
		gint _artists_size_ = 0;
		GtkLabel* _tmp57_ = NULL;
		gchar** _tmp58_ = NULL;
		gint _tmp58__length1 = 0;
		gchar* _tmp59_ = NULL;
		gchar* _tmp60_ = NULL;
		_tmp47_ = self->priv->client;
		_tmp48_ = mpris_client_get_player (_tmp47_);
		_tmp49_ = _tmp48_;
		_tmp50_ = player_iface_get_metadata (_tmp49_);
		_tmp51_ = _tmp50_;
		_tmp52_ = _tmp51_;
		_tmp53_ = g_hash_table_lookup (_tmp52_, "xesam:artist");
		_tmp55_ = g_variant_dup_strv ((GVariant*) _tmp53_, &_tmp54_);
		_tmp56_ = _tmp55_;
		_tmp56__length1 = _tmp54_;
		_g_hash_table_unref0 (_tmp52_);
		artists = _tmp56_;
		artists_length1 = _tmp56__length1;
		_artists_size_ = artists_length1;
		_tmp57_ = self->priv->artist_label;
		_tmp58_ = artists;
		_tmp58__length1 = artists_length1;
		_tmp59_ = _vala_g_strjoinv (", ", _tmp58_, _tmp58__length1);
		_tmp60_ = _tmp59_;
		gtk_label_set_text (_tmp57_, _tmp60_);
		_g_free0 (_tmp60_);
		artists = (_vala_array_free (artists, artists_length1, (GDestroyNotify) g_free), NULL);
	} else {
		GtkLabel* _tmp61_ = NULL;
		_tmp61_ = self->priv->artist_label;
		gtk_label_set_text (_tmp61_, "Unknown Artist");
	}
	_tmp62_ = self->priv->client;
	_tmp63_ = mpris_client_get_player (_tmp62_);
	_tmp64_ = _tmp63_;
	_tmp65_ = player_iface_get_metadata (_tmp64_);
	_tmp66_ = _tmp65_;
	_tmp67_ = _tmp66_;
	_tmp68_ = g_hash_table_contains (_tmp67_, "xesam:album");
	_tmp69_ = _tmp68_;
	_g_hash_table_unref0 (_tmp67_);
	if (_tmp69_) {
		GtkLabel* _tmp70_ = NULL;
		MprisClient* _tmp71_ = NULL;
		PlayerIface* _tmp72_ = NULL;
		PlayerIface* _tmp73_ = NULL;
		GHashTable* _tmp74_ = NULL;
		GHashTable* _tmp75_ = NULL;
		GHashTable* _tmp76_ = NULL;
		gconstpointer _tmp77_ = NULL;
		const gchar* _tmp78_ = NULL;
		_tmp70_ = self->priv->album_label;
		_tmp71_ = self->priv->client;
		_tmp72_ = mpris_client_get_player (_tmp71_);
		_tmp73_ = _tmp72_;
		_tmp74_ = player_iface_get_metadata (_tmp73_);
		_tmp75_ = _tmp74_;
		_tmp76_ = _tmp75_;
		_tmp77_ = g_hash_table_lookup (_tmp76_, "xesam:album");
		_tmp78_ = g_variant_get_string ((GVariant*) _tmp77_, NULL);
		gtk_label_set_text (_tmp70_, _tmp78_);
		_g_hash_table_unref0 (_tmp76_);
	} else {
		GtkLabel* _tmp79_ = NULL;
		_tmp79_ = self->priv->album_label;
		gtk_label_set_text (_tmp79_, "Unknown Album");
	}
}


static void client_widget_class_init (ClientWidgetClass * klass) {
	client_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ClientWidgetPrivate));
	G_OBJECT_CLASS (klass)->finalize = client_widget_finalize;
}


static void client_widget_instance_init (ClientWidget * self) {
	self->priv = CLIENT_WIDGET_GET_PRIVATE (self);
	self->priv->collapsed = FALSE;
}


static void client_widget_finalize (GObject* obj) {
	ClientWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CLIENT_WIDGET, ClientWidget);
	_g_object_unref0 (self->priv->player_revealer);
	_g_object_unref0 (self->priv->background);
	_g_object_unref0 (self->priv->client);
	_g_object_unref0 (self->priv->title_label);
	_g_object_unref0 (self->priv->artist_label);
	_g_object_unref0 (self->priv->album_label);
	_g_object_unref0 (self->priv->prev_btn);
	_g_object_unref0 (self->priv->play_btn);
	_g_object_unref0 (self->priv->next_btn);
	_g_object_unref0 (self->priv->collapse_btn);
	G_OBJECT_CLASS (client_widget_parent_class)->finalize (obj);
}


/**
 * A ClientWidget is simply used to control and display information in a two-way
 * fashion with an underlying MPRIS provider (MediaPlayer2)
 * It is "designed" to be self contained and added to a large UI, enabling multiple
 * MPRIS clients to be controlled with multiple widgets
 */
GType client_widget_get_type (void) {
	static volatile gsize client_widget_type_id__volatile = 0;
	if (g_once_init_enter (&client_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClientWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) client_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClientWidget), 0, (GInstanceInitFunc) client_widget_instance_init, NULL };
		GType client_widget_type_id;
		client_widget_type_id = g_type_register_static (gtk_box_get_type (), "ClientWidget", &g_define_type_info, 0);
		g_once_init_leave (&client_widget_type_id__volatile, client_widget_type_id);
	}
	return client_widget_type_id__volatile;
}


/**
 * Boring utility function, create an image/label row
 *
 * @param name Label to appear on row
 * @param icon Icon name to use, or NULL if using gicon
 * @param gicon A gicon to use, if not using icon
 *
 * @return A Gtk.Box with the boilerplate cruft out of the way
 */
GtkWidget* create_row (const gchar* name, const gchar* icon, GIcon* gicon) {
	GtkWidget* result = NULL;
	GtkBox* box = NULL;
	GtkBox* _tmp0_ = NULL;
	GtkImage* img = NULL;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	GtkImage* _tmp8_ = NULL;
	GtkImage* _tmp9_ = NULL;
	GtkBox* _tmp10_ = NULL;
	GtkImage* _tmp11_ = NULL;
	GtkLabel* label = NULL;
	const gchar* _tmp12_ = NULL;
	GtkLabel* _tmp13_ = NULL;
	GtkBox* _tmp14_ = NULL;
	GtkBox* _tmp15_ = NULL;
	GtkLabel* _tmp16_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp0_);
	box = _tmp0_;
	_tmp2_ = icon;
	if (_tmp2_ == NULL) {
		GIcon* _tmp3_ = NULL;
		_tmp3_ = gicon;
		_tmp1_ = _tmp3_ != NULL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		GIcon* _tmp4_ = NULL;
		GtkImage* _tmp5_ = NULL;
		_tmp4_ = gicon;
		_tmp5_ = (GtkImage*) gtk_image_new_from_gicon (_tmp4_, GTK_ICON_SIZE_MENU);
		g_object_ref_sink (_tmp5_);
		_g_object_unref0 (img);
		img = _tmp5_;
	} else {
		const gchar* _tmp6_ = NULL;
		GtkImage* _tmp7_ = NULL;
		_tmp6_ = icon;
		_tmp7_ = (GtkImage*) gtk_image_new_from_icon_name (_tmp6_, GTK_ICON_SIZE_MENU);
		g_object_ref_sink (_tmp7_);
		_g_object_unref0 (img);
		img = _tmp7_;
	}
	_tmp8_ = img;
	gtk_widget_set_margin_right ((GtkWidget*) _tmp8_, 8);
	_tmp9_ = img;
	gtk_widget_set_margin_left ((GtkWidget*) _tmp9_, 3);
	_tmp10_ = box;
	_tmp11_ = img;
	gtk_box_pack_start (_tmp10_, (GtkWidget*) _tmp11_, FALSE, FALSE, (guint) 0);
	_tmp12_ = name;
	_tmp13_ = (GtkLabel*) gtk_label_new (_tmp12_);
	g_object_ref_sink (_tmp13_);
	label = _tmp13_;
	gtk_label_set_line_wrap (label, TRUE);
	gtk_label_set_line_wrap_mode (label, PANGO_WRAP_WORD);
	gtk_widget_set_halign ((GtkWidget*) label, GTK_ALIGN_START);
	_tmp14_ = box;
	gtk_box_pack_start (_tmp14_, (GtkWidget*) label, TRUE, TRUE, (guint) 0);
	_tmp15_ = box;
	_tmp16_ = _g_object_ref0 (label);
	g_object_set_data_full ((GObject*) _tmp15_, "label_item", _tmp16_, g_object_unref);
	result = (GtkWidget*) box;
	_g_object_unref0 (label);
	_g_object_unref0 (img);
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



