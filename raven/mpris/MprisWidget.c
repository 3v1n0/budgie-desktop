/* MprisWidget.c generated by valac 0.30.0, the Vala compiler
 * generated from MprisWidget.vala, do not modify */

/*
 * MprisWidget.vala
 * 
 * Copyright 2014 Ikey Doherty <ikey.doherty@gmail.com>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_MPRIS_WIDGET (mpris_widget_get_type ())
#define MPRIS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_WIDGET, MprisWidget))
#define MPRIS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_WIDGET, MprisWidgetClass))
#define IS_MPRIS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_WIDGET))
#define IS_MPRIS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_WIDGET))
#define MPRIS_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_WIDGET, MprisWidgetClass))

typedef struct _MprisWidget MprisWidget;
typedef struct _MprisWidgetClass MprisWidgetClass;
typedef struct _MprisWidgetPrivate MprisWidgetPrivate;

#define TYPE_DBUS_IMPL (dbus_impl_get_type ())
#define DBUS_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DBUS_IMPL, DBusImpl))
#define IS_DBUS_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DBUS_IMPL))
#define DBUS_IMPL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_DBUS_IMPL, DBusImplIface))

typedef struct _DBusImpl DBusImpl;
typedef struct _DBusImplIface DBusImplIface;

#define TYPE_DBUS_IMPL_PROXY (dbus_impl_proxy_get_type ())

#define TYPE_CLIENT_WIDGET (client_widget_get_type ())
#define CLIENT_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLIENT_WIDGET, ClientWidget))
#define CLIENT_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLIENT_WIDGET, ClientWidgetClass))
#define IS_CLIENT_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLIENT_WIDGET))
#define IS_CLIENT_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLIENT_WIDGET))
#define CLIENT_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLIENT_WIDGET, ClientWidgetClass))

typedef struct _ClientWidget ClientWidget;
typedef struct _ClientWidgetClass ClientWidgetClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define TYPE_MPRIS_CLIENT (mpris_client_get_type ())
#define MPRIS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CLIENT, MprisClient))
#define MPRIS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CLIENT, MprisClientClass))
#define IS_MPRIS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CLIENT))
#define IS_MPRIS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CLIENT))
#define MPRIS_CLIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CLIENT, MprisClientClass))

typedef struct _MprisClient MprisClient;
typedef struct _MprisClientClass MprisClientClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block4Data Block4Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _MprisWidget {
	GtkBox parent_instance;
	MprisWidgetPrivate * priv;
};

struct _MprisWidgetClass {
	GtkBoxClass parent_class;
};

struct _DBusImplIface {
	GTypeInterface parent_iface;
	gchar** (*list_names) (DBusImpl* self, int* result_length1, GError** error);
};

struct _MprisWidgetPrivate {
	DBusImpl* impl;
	GHashTable* ifaces;
};

struct _Block4Data {
	int _ref_count_;
	MprisWidget* self;
	gchar* n;
};


static gpointer mpris_widget_parent_class = NULL;

GType mpris_widget_get_type (void) G_GNUC_CONST;
GType dbus_impl_proxy_get_type (void) G_GNUC_CONST;
guint dbus_impl_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType dbus_impl_get_type (void) G_GNUC_CONST;
GType client_widget_get_type (void) G_GNUC_CONST;
#define MPRIS_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS_WIDGET, MprisWidgetPrivate))
enum  {
	MPRIS_WIDGET_DUMMY_PROPERTY
};
MprisWidget* mpris_widget_new (void);
MprisWidget* mpris_widget_construct (GType object_type);
static void _g_free0_ (gpointer var);
static void _g_object_unref0_ (gpointer var);
static gboolean __lambda22_ (MprisWidget* self);
void mpris_widget_setup_dbus (MprisWidget* self);
static gboolean ___lambda22__gsource_func (gpointer self);
GType mpris_client_get_type (void) G_GNUC_CONST;
static void mpris_widget_add_iface (MprisWidget* self, const gchar* name, MprisClient* iface);
ClientWidget* client_widget_new (MprisClient* client);
ClientWidget* client_widget_construct (GType object_type, MprisClient* client);
static void mpris_widget_destroy_iface (MprisWidget* self, const gchar* name);
gchar** dbus_impl_list_names (DBusImpl* self, int* result_length1, GError** error);
MprisClient* new_iface (const gchar* busname);
static void ___lambda23_ (MprisWidget* self, const gchar* n, const gchar* o, const gchar* ne);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static gboolean ____lambda24_ (Block4Data* _data4_);
static gboolean _____lambda24__gsource_func (gpointer self);
static void ____lambda23__dbus_impl_name_owner_changed (DBusImpl* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer self);
static void mpris_widget_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static gboolean __lambda22_ (MprisWidget* self) {
	gboolean result = FALSE;
	mpris_widget_setup_dbus (self);
	result = FALSE;
	return result;
}


static gboolean ___lambda22__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda22_ ((MprisWidget*) self);
	return result;
}


MprisWidget* mpris_widget_construct (GType object_type) {
	MprisWidget * self = NULL;
	GHashFunc _tmp0_ = NULL;
	GEqualFunc _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	self = (MprisWidget*) g_object_new (object_type, "orientation", GTK_ORIENTATION_VERTICAL, "spacing", 1, NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (self->priv->ifaces);
	self->priv->ifaces = _tmp2_;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda22__gsource_func, g_object_ref (self), g_object_unref);
	gtk_widget_show_all ((GtkWidget*) self);
	return self;
}


MprisWidget* mpris_widget_new (void) {
	return mpris_widget_construct (TYPE_MPRIS_WIDGET);
}


/**
     * Add an interface handler/widget to known list and UI
     *
     * @param name DBUS name (object path)
     * @param iface The constructed MprisClient instance
     */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void mpris_widget_add_iface (MprisWidget* self, const gchar* name, MprisClient* iface) {
	ClientWidget* widg = NULL;
	MprisClient* _tmp0_ = NULL;
	ClientWidget* _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	ClientWidget* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (iface != NULL);
	_tmp0_ = iface;
	_tmp1_ = client_widget_new (_tmp0_);
	g_object_ref_sink (_tmp1_);
	widg = _tmp1_;
	gtk_widget_show_all ((GtkWidget*) widg);
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) widg, FALSE, FALSE, (guint) 0);
	_tmp2_ = self->priv->ifaces;
	_tmp3_ = name;
	_tmp4_ = g_strdup (_tmp3_);
	_tmp5_ = _g_object_ref0 (widg);
	g_hash_table_insert (_tmp2_, _tmp4_, _tmp5_);
	_g_object_unref0 (widg);
}


/**
     * Destroy an interface handler and remove from UI
     *
     * @param name DBUS name to remove handler for
     */
static void mpris_widget_destroy_iface (MprisWidget* self, const gchar* name) {
	ClientWidget* widg = NULL;
	GHashTable* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	ClientWidget* _tmp3_ = NULL;
	ClientWidget* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->priv->ifaces;
	_tmp1_ = name;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	_tmp3_ = _g_object_ref0 ((ClientWidget*) _tmp2_);
	widg = _tmp3_;
	_tmp4_ = widg;
	if (_tmp4_ != NULL) {
		ClientWidget* _tmp5_ = NULL;
		GHashTable* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		_tmp5_ = widg;
		gtk_container_remove ((GtkContainer*) self, (GtkWidget*) _tmp5_);
		_tmp6_ = self->priv->ifaces;
		_tmp7_ = name;
		g_hash_table_remove (_tmp6_, _tmp7_);
	}
	_g_object_unref0 (widg);
}


/**
     * Do basic dbus initialisation
     */
static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		MprisWidget* self;
		self = _data4_->self;
		_g_free0 (_data4_->n);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static gboolean ____lambda24_ (Block4Data* _data4_) {
	MprisWidget* self;
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	self = _data4_->self;
	_tmp0_ = _data4_->n;
	mpris_widget_destroy_iface (self, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean _____lambda24__gsource_func (gpointer self) {
	gboolean result;
	result = ____lambda24_ (self);
	return result;
}


static void ___lambda23_ (MprisWidget* self, const gchar* n, const gchar* o, const gchar* ne) {
	Block4Data* _data4_;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (n != NULL);
	g_return_if_fail (o != NULL);
	g_return_if_fail (ne != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = n;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data4_->n);
	_data4_->n = _tmp1_;
	_tmp2_ = _data4_->n;
	_tmp3_ = g_str_has_prefix (_tmp2_, "org.mpris.MediaPlayer2.");
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		_tmp4_ = o;
		if (g_strcmp0 (_tmp4_, "") == 0) {
			MprisClient* iface = NULL;
			const gchar* _tmp5_ = NULL;
			MprisClient* _tmp6_ = NULL;
			MprisClient* _tmp7_ = NULL;
			_tmp5_ = _data4_->n;
			_tmp6_ = new_iface (_tmp5_);
			iface = _tmp6_;
			_tmp7_ = iface;
			if (_tmp7_ != NULL) {
				const gchar* _tmp8_ = NULL;
				MprisClient* _tmp9_ = NULL;
				_tmp8_ = _data4_->n;
				_tmp9_ = iface;
				mpris_widget_add_iface (self, _tmp8_, _tmp9_);
			}
			_g_object_unref0 (iface);
		} else {
			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _____lambda24__gsource_func, block4_data_ref (_data4_), block4_data_unref);
		}
	}
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


static void ____lambda23__dbus_impl_name_owner_changed (DBusImpl* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer self) {
	___lambda23_ ((MprisWidget*) self, name, old_owner, new_owner);
}


void mpris_widget_setup_dbus (MprisWidget* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		DBusImpl* _tmp0_ = NULL;
		DBusImpl* _tmp1_ = NULL;
		DBusImpl* _tmp2_ = NULL;
		gchar** names = NULL;
		DBusImpl* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gchar** _tmp5_ = NULL;
		gint names_length1 = 0;
		gint _names_size_ = 0;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		DBusImpl* _tmp15_ = NULL;
		_tmp1_ = g_initable_new (TYPE_DBUS_IMPL_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.DBus", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/freedesktop/DBus", "g-interface-name", "org.freedesktop.DBus", "g-interface-info", g_type_get_qdata (TYPE_DBUS_IMPL, g_quark_from_static_string ("vala-dbus-interface-info")), NULL);
		_tmp0_ = (DBusImpl*) _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch11_g_error;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->impl);
		self->priv->impl = _tmp2_;
		_tmp3_ = self->priv->impl;
		_tmp5_ = dbus_impl_list_names (_tmp3_, &_tmp4_, &_inner_error_);
		names = _tmp5_;
		names_length1 = _tmp4_;
		_names_size_ = names_length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (_tmp0_);
			goto __catch11_g_error;
		}
		_tmp6_ = names;
		_tmp6__length1 = names_length1;
		{
			gchar** name_collection = NULL;
			gint name_collection_length1 = 0;
			gint _name_collection_size_ = 0;
			gint name_it = 0;
			name_collection = _tmp6_;
			name_collection_length1 = _tmp6__length1;
			for (name_it = 0; name_it < _tmp6__length1; name_it = name_it + 1) {
				gchar* _tmp7_ = NULL;
				gchar* name = NULL;
				_tmp7_ = g_strdup (name_collection[name_it]);
				name = _tmp7_;
				{
					const gchar* _tmp8_ = NULL;
					gboolean _tmp9_ = FALSE;
					_tmp8_ = name;
					_tmp9_ = g_str_has_prefix (_tmp8_, "org.mpris.MediaPlayer2.");
					if (_tmp9_) {
						MprisClient* iface = NULL;
						const gchar* _tmp10_ = NULL;
						MprisClient* _tmp11_ = NULL;
						MprisClient* _tmp12_ = NULL;
						_tmp10_ = name;
						_tmp11_ = new_iface (_tmp10_);
						iface = _tmp11_;
						_tmp12_ = iface;
						if (_tmp12_ != NULL) {
							const gchar* _tmp13_ = NULL;
							MprisClient* _tmp14_ = NULL;
							_tmp13_ = name;
							_tmp14_ = iface;
							mpris_widget_add_iface (self, _tmp13_, _tmp14_);
						}
						_g_object_unref0 (iface);
					}
					_g_free0 (name);
				}
			}
		}
		_tmp15_ = self->priv->impl;
		g_signal_connect_object (_tmp15_, "name-owner-changed", (GCallback) ____lambda23__dbus_impl_name_owner_changed, self, 0);
		names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (_tmp0_);
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError* e = NULL;
		GError* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp16_ = e;
		_tmp17_ = _tmp16_->message;
		g_warning ("MprisWidget.vala:97: Failed to initialise dbus: %s", _tmp17_);
		_g_error_free0 (e);
	}
	__finally11:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void mpris_widget_class_init (MprisWidgetClass * klass) {
	mpris_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MprisWidgetPrivate));
	G_OBJECT_CLASS (klass)->finalize = mpris_widget_finalize;
}


static void mpris_widget_instance_init (MprisWidget * self) {
	self->priv = MPRIS_WIDGET_GET_PRIVATE (self);
}


static void mpris_widget_finalize (GObject* obj) {
	MprisWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MPRIS_WIDGET, MprisWidget);
	_g_object_unref0 (self->priv->impl);
	_g_hash_table_unref0 (self->priv->ifaces);
	G_OBJECT_CLASS (mpris_widget_parent_class)->finalize (obj);
}


GType mpris_widget_get_type (void) {
	static volatile gsize mpris_widget_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MprisWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MprisWidget), 0, (GInstanceInitFunc) mpris_widget_instance_init, NULL };
		GType mpris_widget_type_id;
		mpris_widget_type_id = g_type_register_static (gtk_box_get_type (), "MprisWidget", &g_define_type_info, 0);
		g_once_init_leave (&mpris_widget_type_id__volatile, mpris_widget_type_id);
	}
	return mpris_widget_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



